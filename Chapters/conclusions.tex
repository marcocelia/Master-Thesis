\chapter{Conclusions}


The present thesis proposed a Model Based Design tool for system requirements validation and verification. It is possible to locate such framework in the first layer of a V-Model, where usually lie Top-Level (or User) requirements and Verification (or Validation) phases. Has been argued how these two stages can be coupled to enforce their correlation in therms of time and contents. The framework tries to automate such coupling, eliminating the effort for implementing the verification procedures. Moreover, it can be of help in finding the best way for the specification of the requirements itself. Such problem is known in the literature as Virtual Verification \citep{schamai2010virtual}, and can be view as an internal V-Model where the developed product is the requirements specification. Briefly, it expects the development of models which aims to verify textual requirements completeness and correctness.
\paragraph{} The framework comes with the main objective of providing a standard way to couple the usability of a textual representation with the effectiveness of a formal specification. Despite they requires strong technical skills, formal logics represent now-days one of the best way for product certification. The above gap has been reduced involving patterns, but, in order to consider it as a standard approach, a scalability analysis is still required.
\paragraph{} This work offers a proof of concept prototype. As such several features more on the side of classical requirements editors has been sacrificed in favor of a flexible coexistence with modeling environments. Even if in its first version the tool support cooperation only with Simulink, its internal structure allows in small time to experiment whether the approach could fit many others. Next section will discuss about several future works that can improve the overall tool potentiality.

\section{Future Work}

\paragraph{The tool} The requirements tool can be enriched of features exposed by several professionals requirements editors, such as DOORS \citep{DOORS}. Requirements can be hierarchically managed, this is particular useful when top-level requirements have a low-level representation which takes into account how, for instance, the property is mapped into the hardware. Another useful feature could be the capability of internally, or externally, link requirements. The internal links may represent some dependencies among requirements, while external link can be used to immediately point out some models or external file that provides a better explanation of the requirement. Further, a change tracking mechanism is another features that can help users to always have the complete history of the requirements, this is also useful in the process of virtual verification. Another potential service that the tool can provide is the read/write access to the data-dictionary. Since the syntax mostly provide sentences that has names as starting word, having the complete data-dictionary at disposal can help user to correct refer entities.

\paragraph{The Editor} In the current state the editor provides quite interesting capability of syntax coloring and completion. Particularly for the latter, the dynamic syntax loading into Tries is a capability that very easily allows to modify the suggestions. On the other hand the editor does not provide any features of syntax checking, this is surely a good starting point since it can enforce the work done by the syntax helper. Indeed, right now user does not have a real-time feedback for the syntax he is typing, but rather the helper stops providing suggestions if something is wrong in what typed. There are many possible way to implement a syntax checker module, the simplest one could be involving the use of a run-time regular expression marcher, however this at the end provides only a valid-invalid feedback and does not scale very well with the syntax's growth . A better solution could involve again the ANTLR parser, and the redefinition of its errors management strategies. This approach could add to the valid-invalid feedback also the reason of the result, that can be directly provided to the user in order to let him aware.  As a further, minor, improving many compact notation can be used in the syntax, for example numbers such as "0.000001" can be shortly represented as "1e-6". 

\paragraph{MBD features} Many improvements can come also for the MBD perspective. The contract-based formalization can be extended with the concept of precondition, this new section can replace or flank the assumption. Such refinement further enforce the unambiguousness of the requirement since better clarify roles inside it. More on the modeling side the interaction with environment can be improved by eliminating as much as possible the user intermissions. As an example the data-dictionary could be directly generated from a Simulink model without requiring the translation into supported file. Users simply provide as input of the importer a model file and it is converted into a data-dictionary, this features may involve the integration inside the tool of some archive decompressors and file managers. Another interesting feature could be having a real-time interaction with the modeling environment and the editor, which can mark satisfied and violated requirements.
\par The last, and perhaps the most important one, improvement is to extend compatibility with as much modeling environment as possible. Together with Simulink, modeling tools such as Scade \citep{Scade}, Scicos \citep{Scicos}, SysML \citep{sysml}, Modeler\citep{Modeler} and LabView \citep{Labview} find their application in several different domains, but the requirements specification is an omnipresent problem and the possibility to adopt the proposed framework in all these tool could be the key factor of this approach.